# -*- coding: utf-8 -*-
"""project_4_hospital_chatbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jqKQPF0dl1up67wXNW5OtQ-rPL-FN4dQ
"""

# Pip install scikeras and python-Levenshtein, uncomment them and restart the
# session, pip install fuzzywuzzy, uncomment and restart, and then
# everything should be able to run

import numpy as np
import random, time, sys, os

# data processing
import pandas as pd
import json


#!pip install --upgrade tensorflow
import tensorflow as tf

tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)
from tensorflow import keras
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.models import save_model, load_model

# evaluation and hyperparameter tuning
#!pip install scikeras[tensorflow]
from scikeras.wrappers import KerasClassifier
from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.metrics import classification_report
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.optimizers import Adam, SGD
from scipy.stats import uniform

# word processing
#!pip install python-Levenshtein
#!pip install fuzzywuzzy
from fuzzywuzzy import fuzz


# Reading the JSON file
with open("intents.json", "r") as file:
    intents = json.load(file)

# for tag in intents["intents"]:
#     for pattern in tag["patterns"]:
#         print(f"{pattern.lower()}\t{tag['tag']}")

# Creating our training data
with open("training_data_hospitalBot.txt", "a") as f:
    f.write("patterns\ttags\n")
    for tag in intents["intents"]:
        for pattern in tag["patterns"]:
            f.write(f"{pattern.lower()}\t{tag['tag']}\n")

training_data = pd.read_csv("training_data_hospitalBot.txt", delimiter="\t")
training_data.drop(index=training_data.index[0], axis=0, inplace=True)
# Drop the first row which mimics the headings
training_data = training_data.reset_index(drop=True)

# Preprocessing training data
training_data["patterns"] = training_data["patterns"].str.lower()
vectorizer = TfidfVectorizer(ngram_range=(1, 2), stop_words="english")
training_data_tfidf = vectorizer.fit_transform(training_data["patterns"]).toarray()

# Preprocessing target variable (tags)
le = LabelEncoder()
training_data_tags_le = pd.DataFrame({"tags": le.fit_transform(training_data["tags"])})
training_data_tags_dummy_encoded = pd.get_dummies(
    training_data_tags_le["tags"]
).to_numpy()

# # Creating the DNN
# hospitalbot = Sequential()
# hospitalbot.add(Dense(10, input_shape=(len(training_data_tfidf[0]),)))
# hospitalbot.add(Dense(8))
# hospitalbot.add(Dense(8))
# hospitalbot.add(Dense(6))
# hospitalbot.add(Dense(len(training_data_tags_dummy_encoded[0]), activation="softmax"))
# hospitalbot.compile(
#     optimizer="rmsprop", loss="categorical_crossentropy", metrics="accuracy"
# )

# # Fitting DNN
# hospitalbot.fit(
#     training_data_tfidf, training_data_tags_dummy_encoded, epochs=100, batch_size=32
# )

# save_model(hospitalbot, "HospitalBot_v2")

hospitalbot = load_model("HospitalBot_v2")

tags = [item["tag"] for item in intents["intents"]]
resp = [item["responses"] for item in intents["intents"]]
contexts = [item["context"] for item in intents["intents"]]

tag_responses = dict(zip(tags, resp))
tag_contexts = dict(zip(tags, contexts))

json_object = json.dumps(tag_responses, indent=4)

with open("responses.json", "w") as outfile:
    outfile.write(json_object)


# # # Transforming input and predicting intent
# # def predict_tag(user_input):
# #     user_input_tfidf = vectorizer.transform([user_input.lower()]).toarray()
# #     predicted_proba = hospitalbot.predict(user_input_tfidf)
# #     encoded_label = [np.argmax(predicted_proba)]
# #     predicted_tag = le.inverse_transform(encoded_label)[0]
# #     return predicted_tag


# Updated predict_tag function that implements Intent Confidence Threshold
def predict_tag_v2(user_input, confidence_threshold=0.7):
    user_input_tfidf = vectorizer.transform([user_input.lower()]).toarray()
    # print(f"user_input_tfidf: {user_input_tfidf}") For debugging purposes

    predicted_proba = hospitalbot.predict(user_input_tfidf)
    # print(f"predicted_proba: {predicted_proba}") For debugging purposes

    max_confidence = np.max(predicted_proba)

    if max_confidence >= confidence_threshold:
        encoded_label = [np.argmax(predicted_proba)]
        predicted_tag = le.inverse_transform(encoded_label)[0]
        # print(f"predicted_tag: {predicted_tag}") For debugging purposes
        return predicted_tag
    else:
        # If confidence is below the threshold, return a special tag for
        # unknown input
        return "unknown_input"


# Fuzzy matching
def fuzzy_match(user_input, confidence_threshold=0.8, unknown_threshold=70):
    valid_matches = [
        "hospital",
        "pharmacy",
        "blood",
        "blood pressure",
        "adverse drug",
        "hi",
        "hello",
        "help",
    ]

    # Initialize variables to store the best match and its ratio
    best_match = None
    best_ratio = 0

    for valid_match in valid_matches:
        if valid_match.lower() in user_input.lower():  # Exact match for
            # certain keywords
            ratio = 100
        else:
            ratio = fuzz.partial_ratio(user_input, valid_match)

        # Check if the current match has a higher ratio than the best match
        if ratio >= confidence_threshold and ratio > best_ratio:
            best_match = valid_match
            best_ratio = ratio

    if best_match and best_ratio >= unknown_threshold:
        return best_match
    else:
        return "unknown_input"


# Apart from just the tag, we will also consider the current context for
# more context-aware responses and staying on topic
default_messages = [
    "I didn't catch that. Can you please try again?",
    "I'm sorry, I didn't understand that. Can you please provide more information?",
    "I'm not sure I understand. Can you help me understand you better?",
]


def generate_response(input_tag, input_context):
    if input_tag == "unknown_input":
        # If the chatbot doesn't understand, it will display one of our
        # variations of "I don't understand"
        return random.choice(default_messages)
    elif input_context is not None and len(input_context) > 2:
        # If we have a context, use it to fetch responses
        return random.choice(tag_responses.get(input_context, [""]))
    # elif len(input_tag) > 2:
    else:
        # If no context, use the tag to fetch responses
        return random.choice(tag_responses.get(input_tag, [""]))


# Logic to update the current context based on the current tag
# We return an empty string as a default value is the specified key
# is not found
def update_context(input_tag):
    global current_context
    new_context = tag_contexts.get(input_tag, [""])[0]
    current_context = new_context if len(new_context) > 2 else ""


def one_letter_at_a_time(output_string: str):
    for char in output_string:
        print(char, end="")
        sys.stdout.flush()
        time.sleep(0.03)


ending_message = "Good luck! I will be here if you need me again!"


def end_chatbot():
    time.sleep(2)
    one_letter_at_a_time("•\n•\n•\n•\n")
    time.sleep(2)
    one_letter_at_a_time(ending_message)
    time.sleep(1)


current_context = ""  # Initializing current context


def start_chat_v2():
    global current_context
    print("---------------HospitalBot V2---------------")
    print("Ask any queries!")
    print("Type EXIT to quit\n")
    while True:
        user_input = input("Type here: ")
        if user_input == "EXIT":
            time.sleep(1)
            break
        else:
            if user_input:
                # print(f"Current context: {current_context}")
                # For debugging purposes

                # If we have a current context, the tag is grabbed based on
                # the context in the generate_response function
                if current_context is not None and len(current_context) > 2:
                    tag = current_context
                else:
                    # If it's the first time in the chat loop or if we do not have
                    # a current context, we predict the tag based on user input,
                    # after a fuzzy match check
                    fuzzy_check = fuzzy_match(user_input.lower())
                    tag = predict_tag_v2(fuzzy_check)

                # We generate a response with both the current tag and
                # context in mind (if we have one)
                response = generate_response(tag, current_context)

                # Update context based on the current tag
                update_context(tag)  # I had this as an assignment which
                # returned None and it was driving me crazy for an hour
                current_context = current_context
                time.sleep(1)

                # Below are the tags that end the conversation
                # I tried a lot of solutions but I opted for this rather
                # naïve looking one where we have branches of conversation
                # based on the tag. This works because these context-specific
                # tags have no patterns leading to them!
                if tag == "search_blood_pressure_by_patient_id":
                    one_letter_at_a_time(f"{response} #{user_input}\n")
                    end_chatbot()
                    break
                elif tag == "search_pharmacy_by_name":
                    one_letter_at_a_time(f"{response} for {user_input}\n")
                    end_chatbot()
                    break

                # This one is a bit special in that it doesn't end the chatbot
                # Instead it saves the Hospital name/location in order to
                # display it in the next step of the context interaction
                elif tag == "search_hospital_by_params":
                    hospital_param = user_input
                    one_letter_at_a_time(response + "\n")
                    time.sleep(1)
                elif tag == "search_hospital_by_type":
                    if "hospital" in hospital_param.lower():
                        one_letter_at_a_time(f"{response} for {hospital_param}\n")
                    else:
                        one_letter_at_a_time(
                            f"{response} for {hospital_param} {user_input} Hospital\n"
                        )
                    end_chatbot()
                    break

                else:
                    one_letter_at_a_time(response + "\n")
                    time.sleep(1)
            else:
                pass
